import count from "../count";
import countBy from "../countBy";
import getKey from "../../object/getKey";
import identity from "../../core/identity";
import isUndefined from "../../core/isUndefined";
import { nonFunctions, wannabeEmptyArrays } from "../../__tests__/commons";

describe("count / countBy", () => {
    function splitByAgeGroup (person, idx, list) {
        expect(list).toBe(persons);
        expect(persons[idx]).toBe(person);

        return person.age > 20 ? "over20" : "under20";
    }

    const getCity = getKey("city");
    const persons = [
        { name: "Jane", surname: "Doe", age: 12, city: "New York" },
        { name: "John", surname: "Doe", age: 40, city: "New York" },
        { name: "Mario", surname: "Rossi", age: 18, city: "Rome" },
        { name: "Paolo", surname: "Bianchi", age: 15 }
    ];
    const personsCityCount = {
        "New York": 2,
        Rome: 1,
        undefined: 1
    };
    const personsAgeGroupCount = {
        under20: 3,
        over20: 1
    };

    it("should count the occurences of the key generated by the provided iteratee", () => {
        expect(count(persons, getCity)).toStrictEqual(personsCityCount);
        expect(countBy(getCity)(persons)).toStrictEqual(personsCityCount);
        expect(count(persons, splitByAgeGroup)).toStrictEqual(personsAgeGroupCount);
        expect(countBy(splitByAgeGroup)(persons)).toStrictEqual(personsAgeGroupCount);
    });

    it("should work with array-like objects", () => {
        const result = {
            h: 1, e: 1, l: 3, o: 2, " ": 1, w: 1, r: 1, d: 1
        };

        expect(count("hello world", identity)).toStrictEqual(result);
        expect(countBy(identity)("hello world")).toStrictEqual(result);
    });

    it("should throw an exception if the iteratee isn't a function", () => {
        nonFunctions.forEach(value => {
            expect(() => { count(persons, value); }).toThrow();
            expect(() => { countBy(value)(persons); }).toThrow();
        });

        expect(() => { count(persons); }).toThrow();
        expect(() => { countBy()(persons); }).toThrow();
    });

    it("should consider deleted or unassigned indexes in sparse arrays as `undefined` values", () => {
        const arr = [1, , 3, void 0, 5]; // eslint-disable-line no-sparse-arrays
        const result = { false: 3, true: 2 };

        expect(count(arr, isUndefined)).toStrictEqual(result);
        expect(countBy(isUndefined)(arr)).toStrictEqual(result);
    });

    it("should throw an exception if called without the data argument", () => {
        expect(count).toThrow();
        expect(countBy(identity)).toThrow();
    });

    it("should throw an exception if supplied with `null` or `undefined`", () => {
        expect(() => { count(null, identity); }).toThrow();
        expect(() => { count(void 0, identity); }).toThrow();
        expect(() => { countBy(identity)(null); }).toThrow();
        expect(() => { countBy(identity)(void 0); }).toThrow();
    });

    it("should treat every other value as an empty array and return an empty object", () => {
        wannabeEmptyArrays.forEach(value => {
            expect(countBy(identity)(value)).toStrictEqual({});
            expect(count(value, identity)).toStrictEqual({});
        });
    });
});
