import getArgAt from "../../function/getArgAt";
import getKey from "../../object/getKey";
import identity from "../../core/identity";
import index from "../index_";
import indexBy from "../indexBy";
import { nonFunctions, wannabeEmptyArrays } from "../../__tests__/commons";

describe("index / indexBy", () => {
    const getCity = getKey("city");

    const persons = [
        { name: "Jane", surname: "Doe", age: 12, city: "New York" },
        { name: "John", surname: "Doe", age: 40, city: "New York" },
        { name: "Mario", surname: "Rossi", age: 18, city: "Rome" },
        { name: "Paolo", surname: "Bianchi", age: 15 }
    ];

    const personsByAgeIndex = {
        12: { name: "Jane", surname: "Doe", age: 12, city: "New York" },
        15: { name: "Paolo", surname: "Bianchi", age: 15 },
        18: { name: "Mario", surname: "Rossi", age: 18, city: "Rome" },
        40: { name: "John", surname: "Doe", age: 40, city: "New York" }
    };

    const personsByCityIndex = {
        "New York": { name: "John", surname: "Doe", age: 40, city: "New York" },
        Rome: { name: "Mario", surname: "Rossi", age: 18, city: "Rome" },
        undefined: { name: "Paolo", surname: "Bianchi", age: 15 }
    };

    it("should build a lookup table with keys generated by the iteratee and one value for each key from the original list", () => {
        function indexByAge (person, idx, list) {
            expect(list).toBe(persons);
            expect(persons[idx]).toBe(person);

            return person.age;
        }

        expect(index(persons, indexByAge)).toStrictEqual(personsByAgeIndex);
        expect(indexBy(indexByAge)(persons)).toStrictEqual(personsByAgeIndex);
    });

    it("should use the last evaluated value when the iteratee produces a duplicate key", () => {
        expect(index(persons, getCity)).toStrictEqual(personsByCityIndex);
        expect(indexBy(getCity)(persons)).toStrictEqual(personsByCityIndex);
    });

    it("should work with array-like objects", () => {
        const result = {
            h: "h", e: "e", l: "l", o: "o", " ": " ", w: "w", r: "r", d: "d"
        };

        expect(index("hello world", identity)).toStrictEqual(result);
        expect(indexBy(identity)("hello world")).toStrictEqual(result);
    });

    it("should consider deleted or unassigned indexes in sparse arrays as `undefined` values", () => {
        const arr = [1, , 3, void 0, 5]; // eslint-disable-line no-sparse-arrays
        const result = { 0: 1, 1: void 0, 2: 3, 3: void 0, 4: 5 };

        expect(index(arr, getArgAt(1))).toStrictEqual(result);
        expect(indexBy(getArgAt(1))(arr)).toStrictEqual(result);
    });

    it("should throw an exception if the iteratee isn't a function", () => {
        nonFunctions.forEach(value => {
            expect(() => { index(persons, value); }).toThrow();
            expect(() => { indexBy(value)(persons); }).toThrow();
        });

        expect(() => { index(persons); }).toThrow();
        expect(() => { indexBy()(persons); }).toThrow();
    });

    it("should throw an exception if called without the data argument", () => {
        expect(index).toThrow();
        expect(indexBy(identity)).toThrow();
    });

    it("should throw an exception if supplied with `null` or `undefined`", () => {
        expect(() => { index(null, identity); }).toThrow();
        expect(() => { index(void 0, identity); }).toThrow();
        expect(() => { indexBy(identity)(null); }).toThrow();
        expect(() => { indexBy(identity)(void 0); }).toThrow();
    });

    it("should treat every other value as an empty array and return an empty object", () => {
        wannabeEmptyArrays.forEach(value => {
            expect(indexBy(identity)(value)).toStrictEqual({});
            expect(index(value, identity)).toStrictEqual({});
        });
    });
});
